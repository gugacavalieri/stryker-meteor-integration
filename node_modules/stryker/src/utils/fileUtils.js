"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var fs = require("mz/fs");
var path = require("path");
var nodeGlob = require("glob");
var mkdirp = require("mkdirp");
var rimraf = require("rimraf");
function glob(expression) {
    return new Promise(function (resolve, reject) {
        nodeGlob(expression, { nodir: true }, function (error, matches) { error ? reject(error) : resolve(matches); });
    });
}
exports.glob = glob;
function deleteDir(dirToDelete) {
    return new Promise(function (resolve, reject) {
        rimraf(dirToDelete, function (error) { error ? reject(error) : resolve(); });
    });
}
exports.deleteDir = deleteDir;
function cleanFolder(folderName) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var e_1;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 3, , 4]);
                    return [4 /*yield*/, fs.lstat(folderName)];
                case 1:
                    _a.sent();
                    return [4 /*yield*/, deleteDir(folderName)];
                case 2:
                    _a.sent();
                    return [2 /*return*/, mkdirp.sync(folderName)];
                case 3:
                    e_1 = _a.sent();
                    return [2 /*return*/, mkdirp.sync(folderName)];
                case 4: return [2 /*return*/];
            }
        });
    });
}
exports.cleanFolder = cleanFolder;
/**
 * Wrapper around the 'require' function (for testability)
 */
function importModule(moduleName) {
    require(moduleName);
}
exports.importModule = importModule;
/**
 * Writes data to a specified file.
 * @param fileName The path to the file.
 * @param data The content of the file.
 * @returns A promise to eventually save the file.
 */
function writeFile(fileName, data) {
    if (Buffer.isBuffer(data)) {
        return fs.writeFile(fileName, data);
    }
    else {
        return fs.writeFile(fileName, data, 'utf8');
    }
}
exports.writeFile = writeFile;
/**
 * Creates a symlink at `from` that points to `to`
 * @param to The thing you want to point to
 * @param from The thing you want to point from
 */
function symlinkJunction(to, from) {
    return fs.symlink(to, from, 'junction');
}
exports.symlinkJunction = symlinkJunction;
/**
 * Looks for the node_modules folder from basePath up to root.
 * returns the first occurrence of the node_modules, or null of none could be found.
 * @param basePath starting point
 */
function findNodeModules(basePath) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var nodeModules, exists, parent;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    basePath = path.resolve(basePath);
                    nodeModules = path.resolve(basePath, 'node_modules');
                    return [4 /*yield*/, fs.exists(nodeModules)];
                case 1:
                    exists = _a.sent();
                    if (exists) {
                        return [2 /*return*/, nodeModules];
                    }
                    else {
                        parent = path.dirname(basePath);
                        if (parent === basePath) {
                            return [2 /*return*/, null];
                        }
                        else {
                            return [2 /*return*/, findNodeModules(path.dirname(basePath))];
                        }
                    }
                    return [2 /*return*/];
            }
        });
    });
}
exports.findNodeModules = findNodeModules;
//# sourceMappingURL=fileUtils.js.map