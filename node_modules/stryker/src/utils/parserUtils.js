"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("lodash");
var esprima = require("esprima");
var escodegen = require('escodegen');
/**
 * Utility class for parsing and generating code.
 * @constructor
 */
var esprimaOptions = {
    comment: true,
    loc: true,
    range: true,
    tokens: true,
};
/**
 * Parses code to generate an Abstract Syntax Tree.
 * @function
 * @param code - The code which has to be parsed.
 * @returns {Object} The generated Abstract Syntax Tree.
 */
function parse(code) {
    if (code === undefined) {
        throw new Error('Code parameter cannot be undefined');
    }
    var abstractSyntaxTree = esprima.parse(code, esprimaOptions);
    return abstractSyntaxTree;
}
exports.parse = parse;
/**
   * Parses a Node to generate code.
   * @param The Node which has to be transformed into code.
   * @returns The generated code.
   */
function generate(node) {
    return escodegen.generate(node);
}
exports.generate = generate;
/**
 * Returns n as T & Identified, purely syntactic.
 * @param n The estree node which is identified
 */
function identified(n) {
    return n;
}
exports.identified = identified;
/**
 * Represents an object responsible to identify estree nodes (estree.Node).
 * Labels all nodes with a `nodeID` recursively.
 */
var NodeIdentifier = /** @class */ (function () {
    function NodeIdentifier() {
        this.identifiedNodes = [];
    }
    NodeIdentifier.prototype.identifyAndFreeze = function (program) {
        this.identifiedNodes = [];
        this.identifyAndFreezeRecursively(program);
        return this.identifiedNodes;
    };
    NodeIdentifier.prototype.identifyAndFreezeRecursively = function (maybeNode) {
        var _this = this;
        if (this.isNode(maybeNode)) {
            if (!this.isIdentified(maybeNode)) {
                this.identify(maybeNode);
            }
            Object.freeze(maybeNode);
            _.forOwn(maybeNode, function (childNode) {
                _this.identifyAndFreezeRecursively(childNode);
            });
        }
        else if (Array.isArray(maybeNode)) {
            maybeNode.forEach(function (grandChild) {
                _this.identifyAndFreezeRecursively(grandChild);
            });
        }
    };
    NodeIdentifier.prototype.isNode = function (maybeNode) {
        return !_.isArray(maybeNode) && _.isObject(maybeNode) && maybeNode.type;
    };
    NodeIdentifier.prototype.isIdentified = function (node) {
        var n = node;
        return _.isNumber(n.nodeID);
    };
    NodeIdentifier.prototype.identify = function (node) {
        var n = node;
        n.nodeID = this.identifiedNodes.length;
        this.identifiedNodes.push(n);
    };
    return NodeIdentifier;
}());
exports.NodeIdentifier = NodeIdentifier;
//# sourceMappingURL=parserUtils.js.map