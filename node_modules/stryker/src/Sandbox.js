"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var path = require("path");
var log4js_1 = require("log4js");
var mkdirp = require("mkdirp");
var objectUtils_1 = require("./utils/objectUtils");
var ResilientTestRunnerFactory_1 = require("./isolated-runner/ResilientTestRunnerFactory");
var TempFolder_1 = require("./utils/TempFolder");
var fileUtils_1 = require("./utils/fileUtils");
var TestableMutant_1 = require("./TestableMutant");
var Sandbox = /** @class */ (function () {
    function Sandbox(options, index, files, testFramework, timeOverheadMS) {
        this.options = options;
        this.index = index;
        this.testFramework = testFramework;
        this.timeOverheadMS = timeOverheadMS;
        this.log = log4js_1.getLogger(Sandbox.name);
        this.workingFolder = TempFolder_1.TempFolder.instance().createRandomFolder('sandbox');
        this.log.debug('Creating a sandbox for files in %s', this.workingFolder);
        this.files = files.slice(); // Create a copy
    }
    Sandbox.prototype.initialize = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.fillSandbox()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.symlinkNodeModulesIfNeeded()];
                    case 2:
                        _a.sent();
                        return [2 /*return*/, this.initializeTestRunner()];
                }
            });
        });
    };
    Sandbox.create = function (options, index, files, testFramework, timeoutOverheadMS) {
        var sandbox = new Sandbox(options, index, files, testFramework, timeoutOverheadMS);
        return sandbox.initialize().then(function () { return sandbox; });
    };
    Sandbox.prototype.run = function (timeout, testHooks) {
        return this.testRunner.run({ timeout: timeout, testHooks: testHooks });
    };
    Sandbox.prototype.dispose = function () {
        return this.testRunner.dispose() || Promise.resolve();
    };
    Sandbox.prototype.runMutant = function (transpiledMutant) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var mutantFiles, runResult;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        mutantFiles = transpiledMutant.transpileResult.outputFiles;
                        if (transpiledMutant.mutant.testSelectionResult === TestableMutant_1.TestSelectionResult.Failed) {
                            this.log.warn("Failed find coverage data for this mutant, running all tests. This might have an impact on performance: " + transpiledMutant.mutant.toString());
                        }
                        return [4 /*yield*/, Promise.all(mutantFiles.map(function (mutatedFile) { return _this.writeFileInSandbox(mutatedFile); }))];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.run(this.calculateTimeout(transpiledMutant.mutant), this.getFilterTestsHooks(transpiledMutant.mutant))];
                    case 2:
                        runResult = _a.sent();
                        return [4 /*yield*/, this.reset(mutantFiles)];
                    case 3:
                        _a.sent();
                        return [2 /*return*/, runResult];
                }
            });
        });
    };
    Sandbox.prototype.reset = function (mutatedFiles) {
        var _this = this;
        var originalFiles = this.files.filter(function (originalFile) { return mutatedFiles.some(function (mutatedFile) { return mutatedFile.name === originalFile.name; }); });
        return Promise.all(originalFiles.map(function (file) { return fileUtils_1.writeFile(_this.fileMap[file.name], file.content); }));
    };
    Sandbox.prototype.writeFileInSandbox = function (file) {
        var fileNameInSandbox = this.fileMap[file.name];
        return fileUtils_1.writeFile(fileNameInSandbox, file.content);
    };
    Sandbox.prototype.fillSandbox = function () {
        var _this = this;
        this.fileMap = Object.create(null);
        var copyPromises = this.files
            .map(function (file) { return _this.fillFile(file); });
        return Promise.all(copyPromises);
    };
    Sandbox.prototype.symlinkNodeModulesIfNeeded = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var basePath, nodeModules_1;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.options.symlinkNodeModules) return [3 /*break*/, 4];
                        basePath = process.cwd();
                        return [4 /*yield*/, fileUtils_1.findNodeModules(basePath)];
                    case 1:
                        nodeModules_1 = _a.sent();
                        if (!nodeModules_1) return [3 /*break*/, 3];
                        return [4 /*yield*/, fileUtils_1.symlinkJunction(nodeModules_1, path.join(this.workingFolder, 'node_modules'))
                                .catch(function (error) {
                                if (error.code === 'EEXIST') {
                                    _this.log.warn(objectUtils_1.normalizeWhiteSpaces("Could not symlink \"" + nodeModules_1 + "\" in sandbox directory, \n              it is already created in the sandbox. Please remove the node_modules from your sandbox files. \n              Alternatively, set `symlinkNodeModules` to `false` to disable this warning."));
                                }
                                else {
                                    _this.log.warn("Unexpected error while trying to symlink \"" + nodeModules_1 + "\" in sandbox directory.", error);
                                }
                            })];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        this.log.warn("Could not find a node_modules folder to symlink into the sandbox directory. Search \"" + basePath + "\" and its parent directories");
                        _a.label = 4;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    Sandbox.prototype.fillFile = function (file) {
        var relativePath = path.relative(process.cwd(), file.name);
        var folderName = path.join(this.workingFolder, path.dirname(relativePath));
        mkdirp.sync(folderName);
        var targetFile = path.join(folderName, path.basename(relativePath));
        this.fileMap[file.name] = targetFile;
        return fileUtils_1.writeFile(targetFile, file.content);
    };
    Sandbox.prototype.initializeTestRunner = function () {
        var _this = this;
        var settings = {
            fileNames: Object.keys(this.fileMap).map(function (sourceFileName) { return _this.fileMap[sourceFileName]; }),
            strykerOptions: this.options,
            port: this.options.port + this.index,
            sandboxWorkingFolder: this.workingFolder
        };
        this.log.debug("Creating test runner %s using settings {port: %s}", this.index, settings.port);
        this.testRunner = ResilientTestRunnerFactory_1.default.create(settings.strykerOptions.testRunner || '', settings);
        return this.testRunner.init();
    };
    Sandbox.prototype.calculateTimeout = function (mutant) {
        var baseTimeout = mutant.timeSpentScopedTests;
        return (this.options.timeoutFactor * baseTimeout) + this.options.timeoutMs + this.timeOverheadMS;
    };
    Sandbox.prototype.getFilterTestsHooks = function (mutant) {
        if (this.testFramework) {
            return objectUtils_1.wrapInClosure(this.testFramework.filter(mutant.selectedTests));
        }
        else {
            return undefined;
        }
    };
    return Sandbox;
}());
exports.default = Sandbox;
//# sourceMappingURL=Sandbox.js.map