"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var path = require("path");
var _ = require("lodash");
var log4js_1 = require("log4js");
var report_1 = require("stryker-api/report");
var objectUtils_1 = require("./utils/objectUtils");
var defaultScoreIfNoValidMutants = 100;
var ScoreResultCalculator = /** @class */ (function () {
    function ScoreResultCalculator() {
        this.log = log4js_1.getLogger(ScoreResultCalculator.name);
    }
    ScoreResultCalculator.prototype.calculate = function (results) {
        var scoreResult = this.calculateScoreResult(results, '');
        return this.wrapIfSingleFileScoreResult(scoreResult);
    };
    ScoreResultCalculator.prototype.determineExitCode = function (score, thresholds) {
        var breaking = thresholds && thresholds.break;
        var formattedScore = score.mutationScore.toFixed(2);
        if (typeof breaking === 'number') {
            if (score.mutationScore < breaking) {
                this.log.error("Final mutation score " + formattedScore + " under breaking threshold " + breaking + ", setting exit code to 1 (failure).");
                this.log.info('(improve mutation score or set `thresholds.break = null` to prevent this error in the future)');
                objectUtils_1.setExitCode(1);
            }
            else {
                this.log.info("Final mutation score of " + formattedScore + " is greater than or equal to break threshold " + breaking);
            }
        }
        else {
            this.log.debug('No breaking threshold configured. Won\'t fail the build no matter how low your mutation score is. Set `thresholds.break` to change this behavior.');
        }
    };
    ScoreResultCalculator.prototype.wrapIfSingleFileScoreResult = function (scoreResult) {
        if (scoreResult.representsFile) {
            return this.copy(scoreResult, {
                name: path.dirname(scoreResult.name), childResults: [
                    this.copy(scoreResult, { name: path.basename(scoreResult.name) })
                ]
            });
        }
        else {
            return scoreResult;
        }
    };
    ScoreResultCalculator.prototype.calculateScoreResult = function (results, basePath) {
        var numbers = this.countNumbers(results);
        var facts = this.determineFacts(basePath, results);
        return objectUtils_1.freezeRecursively(_.assign(numbers, facts));
    };
    ScoreResultCalculator.prototype.copy = function (defaults, overrides) {
        return Object.assign({}, defaults, overrides);
    };
    ScoreResultCalculator.prototype.determineFacts = function (basePath, results) {
        var name = this.determineCommonBasePath(results, basePath);
        var childResults = this.calculateChildScores(results, name, basePath);
        return {
            name: name,
            path: path.join(basePath, name),
            childResults: childResults,
            representsFile: childResults.length === 0 && results.length > 0
        };
    };
    ScoreResultCalculator.prototype.compareScoreResults = function (a, b) {
        var sortValue = function (scoreResult) {
            // Directories first
            if (scoreResult.representsFile) {
                return "1" + scoreResult.name;
            }
            else {
                return "0" + scoreResult.name;
            }
        };
        return sortValue(a).localeCompare(sortValue(b));
    };
    ScoreResultCalculator.prototype.calculateChildScores = function (results, parentName, basePath) {
        var _this = this;
        var childrenBasePath = parentName.length ? path.join(basePath, parentName) + path.sep : '';
        var resultsGroupedByFiles = _.groupBy(results, function (result) { return result.sourceFilePath.substr(childrenBasePath.length); });
        var uniqueFiles = Object.keys(resultsGroupedByFiles);
        if (uniqueFiles.length > 1) {
            var filesGroupedByDirectory_1 = _.groupBy(uniqueFiles, function (file) { return file.split(path.sep)[0]; });
            return Object.keys(filesGroupedByDirectory_1)
                .map(function (directory) { return _this.calculateScoreResult(_.flatMap(filesGroupedByDirectory_1[directory], function (file) { return resultsGroupedByFiles[file]; }), childrenBasePath); })
                .sort(this.compareScoreResults);
        }
        else {
            return [];
        }
    };
    ScoreResultCalculator.prototype.determineCommonBasePath = function (results, basePath) {
        var uniqueFiles = _.uniq(results.map(function (result) { return result.sourceFilePath; }));
        var uniqueFileDirectories = uniqueFiles.map(function (file) { return file.substr(basePath.length).split(path.sep); });
        if (uniqueFileDirectories.length) {
            return uniqueFileDirectories
                .reduce(function (previousDirectories, currentDirectories) { return previousDirectories.filter(function (token, index) { return currentDirectories[index] === token; }); })
                .join(path.sep);
        }
        else {
            return '';
        }
    };
    ScoreResultCalculator.prototype.countNumbers = function (mutantResults) {
        var count = function (mutantResult) { return mutantResults.filter(function (_) { return _.status === mutantResult; }).length; };
        var killed = count(report_1.MutantStatus.Killed);
        var timedOut = count(report_1.MutantStatus.TimedOut);
        var survived = count(report_1.MutantStatus.Survived);
        var noCoverage = count(report_1.MutantStatus.NoCoverage);
        var runtimeErrors = count(report_1.MutantStatus.RuntimeError);
        var transpileErrors = count(report_1.MutantStatus.TranspileError);
        var totalDetected = timedOut + killed;
        var totalUndetected = survived + noCoverage;
        var totalCovered = totalDetected + survived;
        var totalValid = totalUndetected + totalDetected;
        var totalInvalid = runtimeErrors + transpileErrors;
        var totalMutants = totalValid + totalInvalid;
        var mutationScore = totalValid > 0 ? totalDetected / totalValid * 100 : defaultScoreIfNoValidMutants;
        var mutationScoreBasedOnCoveredCode = totalValid > 0 ? totalDetected / totalCovered * 100 || 0 : defaultScoreIfNoValidMutants;
        return {
            killed: killed,
            survived: survived,
            noCoverage: noCoverage,
            runtimeErrors: runtimeErrors,
            transpileErrors: transpileErrors,
            timedOut: timedOut,
            totalDetected: totalDetected,
            totalUndetected: totalUndetected,
            totalCovered: totalCovered,
            totalValid: totalValid,
            totalInvalid: totalInvalid,
            totalMutants: totalMutants,
            mutationScore: mutationScore,
            mutationScoreBasedOnCoveredCode: mutationScoreBasedOnCoveredCode
        };
    };
    return ScoreResultCalculator;
}());
exports.default = ScoreResultCalculator;
//# sourceMappingURL=ScoreResultCalculator.js.map