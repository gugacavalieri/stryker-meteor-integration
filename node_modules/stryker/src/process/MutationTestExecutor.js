"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var rxjs_1 = require("rxjs");
var operators_1 = require("rxjs/operators");
var report_1 = require("stryker-api/report");
var test_runner_1 = require("stryker-api/test_runner");
var SandboxPool_1 = require("../SandboxPool");
var MutantTranspiler_1 = require("../transpiler/MutantTranspiler");
var MutationTestExecutor = /** @class */ (function () {
    function MutationTestExecutor(config, inputFiles, testFramework, reporter, overheadTimeMS) {
        this.config = config;
        this.inputFiles = inputFiles;
        this.testFramework = testFramework;
        this.reporter = reporter;
        this.overheadTimeMS = overheadTimeMS;
    }
    MutationTestExecutor.prototype.run = function (allMutants) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var mutantTranspiler, transpiledFiles, sandboxPool, result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        mutantTranspiler = new MutantTranspiler_1.default(this.config);
                        return [4 /*yield*/, mutantTranspiler.initialize(this.inputFiles)];
                    case 1:
                        transpiledFiles = _a.sent();
                        sandboxPool = new SandboxPool_1.default(this.config, this.testFramework, transpiledFiles, this.overheadTimeMS);
                        return [4 /*yield*/, this.runInsideSandboxes(sandboxPool.streamSandboxes(), mutantTranspiler.transpileMutants(allMutants))];
                    case 2:
                        result = _a.sent();
                        return [4 /*yield*/, sandboxPool.disposeAll()];
                    case 3:
                        _a.sent();
                        mutantTranspiler.dispose();
                        return [2 /*return*/, result];
                }
            });
        });
    };
    MutationTestExecutor.prototype.runInsideSandboxes = function (sandboxes, transpiledMutants) {
        var recycleObserver;
        var recycled = new rxjs_1.Observable(function (observer) {
            recycleObserver = observer;
        });
        function recycle(sandbox) {
            return recycleObserver.next(sandbox.sandbox);
        }
        function completeRecycle() {
            if (recycleObserver) {
                recycleObserver.complete();
            }
        }
        return rxjs_1.zip(transpiledMutants, rxjs_1.merge(recycled, sandboxes), createTuple)
            .pipe(operators_1.map(earlyResult), operators_1.flatMap(runInSandbox), operators_1.tap(recycle), operators_1.map(function (_a) {
            var result = _a.result;
            return result;
        }), operators_1.tap(reportResult(this.reporter)), operators_1.toArray(), operators_1.tap(completeRecycle), operators_1.tap(reportAll(this.reporter)))
            .toPromise(Promise);
    };
    return MutationTestExecutor;
}());
exports.default = MutationTestExecutor;
function earlyResult(_a) {
    var transpiledMutant = _a[0], sandbox = _a[1];
    if (transpiledMutant.transpileResult.error) {
        var result = transpiledMutant.mutant.result(report_1.MutantStatus.TranspileError, []);
        return [transpiledMutant, sandbox, result];
    }
    else if (!transpiledMutant.mutant.selectedTests.length) {
        var result = transpiledMutant.mutant.result(report_1.MutantStatus.NoCoverage, []);
        return [transpiledMutant, sandbox, result];
    }
    else if (!transpiledMutant.changedAnyTranspiledFiles) {
        var result = transpiledMutant.mutant.result(report_1.MutantStatus.Survived, []);
        return [transpiledMutant, sandbox, result];
    }
    else {
        // No early result possible, need to run in the sandbox later
        return [transpiledMutant, sandbox, null];
    }
}
function runInSandbox(_a) {
    var transpiledMutant = _a[0], sandbox = _a[1], earlyResult = _a[2];
    if (earlyResult) {
        return Promise.resolve({ sandbox: sandbox, result: earlyResult });
    }
    else {
        return sandbox.runMutant(transpiledMutant)
            .then(function (runResult) { return ({ sandbox: sandbox, result: collectMutantResult(transpiledMutant.mutant, runResult) }); });
    }
}
function createTuple(a, b) {
    return [a, b];
}
function collectMutantResult(mutant, runResult) {
    var status = report_1.MutantStatus.NoCoverage;
    var testNames;
    if (runResult) {
        switch (runResult.status) {
            case test_runner_1.RunStatus.Timeout:
                status = report_1.MutantStatus.TimedOut;
                break;
            case test_runner_1.RunStatus.Error:
                status = report_1.MutantStatus.RuntimeError;
                break;
            case test_runner_1.RunStatus.Complete:
                if (runResult.tests.some(function (t) { return t.status === test_runner_1.TestStatus.Failed; })) {
                    status = report_1.MutantStatus.Killed;
                }
                else {
                    status = report_1.MutantStatus.Survived;
                }
                break;
        }
        testNames = runResult.tests
            .filter(function (t) { return t.status !== test_runner_1.TestStatus.Skipped; })
            .map(function (t) { return t.name; });
    }
    else {
        testNames = [];
    }
    return mutant.result(status, testNames);
}
function reportResult(reporter) {
    return function (mutantResult) {
        reporter.onMutantTested(mutantResult);
    };
}
function reportAll(reporter) {
    return function (mutantResults) {
        reporter.onAllMutantsTested(mutantResults);
    };
}
//# sourceMappingURL=MutationTestExecutor.js.map