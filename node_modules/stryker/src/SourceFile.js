"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isLineBreak(ch) {
    // ES5 7.3:
    // The ECMAScript line terminator characters are listed in Table 3.
    //     Table 3: Line Terminator Characters
    //     Code Unit Value     Name                    Formal Name
    //     \u000A              Line Feed               <LF>
    //     \u000D              Carriage Return         <CR>
    //     \u2028              Line separator          <LS>
    //     \u2029              Paragraph separator     <PS>
    // Only the characters in Table 3 are treated as line terminators. Other new line or line
    // breaking characters are treated as white space but not as line terminators.
    return ch === 10 /* lineFeed */ ||
        ch === 13 /* carriageReturn */ ||
        ch === 8232 /* lineSeparator */ ||
        ch === 8233 /* paragraphSeparator */;
}
exports.isLineBreak = isLineBreak;
var SourceFile = /** @class */ (function () {
    function SourceFile(file) {
        this.file = file;
        this.lineStarts = this.computeLineStarts();
    }
    Object.defineProperty(SourceFile.prototype, "name", {
        get: function () {
            return this.file.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SourceFile.prototype, "content", {
        get: function () {
            return this.file.textContent;
        },
        enumerable: true,
        configurable: true
    });
    SourceFile.prototype.getLocation = function (range) {
        return {
            start: this.getPosition(range[0]),
            end: this.getPosition(range[1])
        };
    };
    SourceFile.prototype.getPosition = function (pos) {
        var lineNumber = this.binarySearch(pos);
        if (lineNumber < 0) {
            // If the actual position was not found,
            // the binary search returns the 2's-complement of the next line start
            // e.g. if the line starts at [5, 10, 23, 80] and the position requested was 20
            // then the search will return -2.
            //
            // We want the index of the previous line start, so we subtract 1.
            // Review 2's-complement if this is confusing.
            lineNumber = ~lineNumber - 1;
        }
        return {
            line: lineNumber,
            column: pos - this.lineStarts[lineNumber]
        };
    };
    /**
       * Performs a binary search, finding the index at which 'value' occurs in 'array'.
       * If no such index is found, returns the 2's-complement of first index at which
       * number[index] exceeds number.
       * @param array A sorted array whose first element must be no larger than number
       * @param number The value to be searched for in the array.
       */
    SourceFile.prototype.binarySearch = function (position, offset) {
        if (offset === void 0) { offset = 0; }
        var low = offset;
        var high = this.lineStarts.length - 1;
        while (low <= high) {
            var middle = low + ((high - low) >> 1);
            var midValue = this.lineStarts[middle];
            if (midValue === position) {
                return middle;
            }
            else if (midValue > position) {
                high = middle - 1;
            }
            else {
                low = middle + 1;
            }
        }
        return ~low;
    };
    SourceFile.prototype.computeLineStarts = function () {
        var result = [];
        var pos = 0;
        var lineStart = 0;
        while (pos < this.file.textContent.length) {
            var ch = this.file.textContent.charCodeAt(pos);
            pos++;
            switch (ch) {
                case 13 /* carriageReturn */:
                    if (this.file.textContent.charCodeAt(pos) === 10 /* lineFeed */) {
                        pos++;
                    }
                // falls through
                case 10 /* lineFeed */:
                    result.push(lineStart);
                    lineStart = pos;
                    break;
                default:
                    if (ch > 127 /* maxAsciiCharacter */ && isLineBreak(ch)) {
                        result.push(lineStart);
                        lineStart = pos;
                    }
                    break;
            }
        }
        result.push(lineStart);
        return result;
    };
    return SourceFile;
}());
exports.default = SourceFile;
//# sourceMappingURL=SourceFile.js.map