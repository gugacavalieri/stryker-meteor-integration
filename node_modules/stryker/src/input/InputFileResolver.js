"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var path = require("path");
var fs = require("mz/fs");
var child_process_1 = require("mz/child_process");
var log4js_1 = require("log4js");
var core_1 = require("stryker-api/core");
var fileUtils_1 = require("../utils/fileUtils");
var StrykerError_1 = require("../utils/StrykerError");
var InputFileCollection_1 = require("./InputFileCollection");
var objectUtils_1 = require("../utils/objectUtils");
function toReportSourceFile(file) {
    return {
        path: file.name,
        content: file.textContent
    };
}
var InputFileResolver = /** @class */ (function () {
    function InputFileResolver(mutate, files, reporter) {
        this.reporter = reporter;
        this.log = log4js_1.getLogger(InputFileResolver.name);
        this.mutateResolver = PatternResolver.parse(mutate || []);
        if (files) {
            this.fileResolver = PatternResolver.parse(files);
        }
    }
    InputFileResolver.prototype.resolve = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, inputFileNames, mutateFiles, files, inputFileCollection;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, Promise.all([this.resolveInputFiles(), this.mutateResolver.resolve()])];
                    case 1:
                        _a = _b.sent(), inputFileNames = _a[0], mutateFiles = _a[1];
                        return [4 /*yield*/, this.readFiles(inputFileNames)];
                    case 2:
                        files = _b.sent();
                        inputFileCollection = new InputFileCollection_1.default(files, mutateFiles);
                        this.reportAllSourceFilesRead(files);
                        inputFileCollection.logFiles(this.log);
                        return [2 /*return*/, inputFileCollection];
                }
            });
        });
    };
    InputFileResolver.prototype.resolveInputFiles = function () {
        if (this.fileResolver) {
            return this.fileResolver.resolve();
        }
        else {
            return this.resolveFilesUsingGit();
        }
    };
    InputFileResolver.prototype.resolveFilesUsingGit = function () {
        return child_process_1.exec('git ls-files --others --exclude-standard --cached --exclude .stryker-tmp', { maxBuffer: 10 * 1000 * 1024 })
            .then(function (_a) {
            var stdout = _a[0];
            return stdout.toString();
        })
            .then(function (output) { return output.split('\n').map(function (fileName) { return fileName.trim(); }); })
            .then(function (fileNames) { return fileNames.filter(function (fileName) { return fileName; }).map(function (fileName) { return path.resolve(fileName); }); })
            .catch(function (error) {
            throw new StrykerError_1.default("Cannot determine input files. Either specify a `files` array in your stryker configuration, or make sure \"" + process.cwd() + "\" is located inside a git repository", error);
        });
    };
    InputFileResolver.prototype.reportAllSourceFilesRead = function (allFiles) {
        this.reporter.onAllSourceFilesRead(allFiles.map(toReportSourceFile));
    };
    InputFileResolver.prototype.reportSourceFilesRead = function (textFile) {
        this.reporter.onSourceFileRead(toReportSourceFile(textFile));
    };
    InputFileResolver.prototype.readFiles = function (files) {
        var _this = this;
        return Promise.all(files.map(function (fileName) { return _this.readFile(fileName); }))
            .then(objectUtils_1.filterEmpty);
    };
    InputFileResolver.prototype.readFile = function (fileName) {
        var _this = this;
        return fs.readFile(fileName).then(function (content) { return new core_1.File(fileName, content); })
            .then(function (file) {
            _this.reportSourceFilesRead(file);
            return file;
        }).catch(function (error) {
            if (objectUtils_1.isErrnoException(error) && error.code === 'ENOENT') {
                return null; // file is deleted. This can be a valid result of the git command
            }
            else {
                // Rethrow
                throw error;
            }
        });
    };
    return InputFileResolver;
}());
exports.default = InputFileResolver;
var PatternResolver = /** @class */ (function () {
    function PatternResolver(globExpression, previous) {
        this.previous = previous;
        this.log = log4js_1.getLogger(InputFileResolver.name);
        this.ignore = false;
        this.ignore = globExpression.indexOf('!') === 0;
        if (this.ignore) {
            this.globExpression = globExpression.substring(1);
        }
        else {
            this.globExpression = globExpression;
        }
    }
    PatternResolver.normalize = function (inputFileExpressions) {
        var inputFileDescriptorObjects = [];
        var globExpressions = inputFileExpressions.map(function (expression) {
            if (typeof expression === 'string') {
                return expression;
            }
            else {
                inputFileDescriptorObjects.push(expression);
                return expression.pattern;
            }
        });
        if (inputFileDescriptorObjects.length) {
            new PatternResolver('').log.warn(objectUtils_1.normalizeWhiteSpaces("\n      DEPRECATED: Using the `InputFileDescriptor` syntax to \n      select files is no longer supported. We'll assume: " + JSON.stringify(inputFileDescriptorObjects) + " can be migrated \n      to " + JSON.stringify(inputFileDescriptorObjects.map(function (_) { return _.pattern; })) + " for this mutation run.\n      Please move any files to mutate into the `mutate` array (top level stryker option).\n      You can fix this warning in 2 ways:\n      1) If your project is under git version control, you can remove the \"files\" patterns all together. \n      Stryker can figure it out for you.\n      2) If your project is not under git version control or you need ignored files in your sandbox, you can replace the \n      `InputFileDescriptor` syntax with strings (as done for this test run)."));
        }
        return globExpressions;
    };
    PatternResolver.prototype.resolve = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var globbingTask, results, previousFiles_1, currentFiles_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.ignore && !this.previous)) return [3 /*break*/, 1];
                        return [2 /*return*/, Promise.resolve([])];
                    case 1:
                        globbingTask = this.resolveGlobbingExpression(this.globExpression);
                        if (!this.previous) return [3 /*break*/, 3];
                        return [4 /*yield*/, Promise.all([this.previous.resolve(), globbingTask])];
                    case 2:
                        results = _a.sent();
                        previousFiles_1 = results[0];
                        currentFiles_1 = results[1];
                        // If this expression started with a '!', exclude current files
                        if (this.ignore) {
                            return [2 /*return*/, previousFiles_1.filter(function (previousFile) { return currentFiles_1.every(function (currentFile) { return previousFile !== currentFile; }); })];
                        }
                        else {
                            // Only add files which were not already added
                            return [2 /*return*/, previousFiles_1.concat(currentFiles_1.filter(function (currentFile) { return !previousFiles_1.some(function (file) { return file === currentFile; }); }))];
                        }
                        return [3 /*break*/, 4];
                    case 3: return [2 /*return*/, globbingTask];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    PatternResolver.empty = function () {
        var emptyResolver = new PatternResolver('');
        emptyResolver.ignore = true;
        return emptyResolver;
    };
    PatternResolver.parse = function (inputFileExpressions) {
        var expressions = this.normalize(inputFileExpressions);
        var current = PatternResolver.empty();
        var expression = expressions.shift();
        while (expression) {
            current = new PatternResolver(expression, current);
            expression = expressions.shift();
        }
        return current;
    };
    PatternResolver.prototype.resolveGlobbingExpression = function (pattern) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var files;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fileUtils_1.glob(pattern)];
                    case 1:
                        files = _a.sent();
                        if (files.length === 0) {
                            this.reportEmptyGlobbingExpression(pattern);
                        }
                        return [2 /*return*/, files.map(function (f) { return path.resolve(f); })];
                }
            });
        });
    };
    PatternResolver.prototype.reportEmptyGlobbingExpression = function (expression) {
        this.log.warn("Globbing expression \"" + expression + "\" did not result in any files.");
    };
    return PatternResolver;
}());
//# sourceMappingURL=InputFileResolver.js.map