"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var log4js_1 = require("log4js");
var core_1 = require("stryker-api/core");
var objectUtils_1 = require("../utils/objectUtils");
var messageProtocol_1 = require("./messageProtocol");
var PluginLoader_1 = require("../PluginLoader");
var ChildProcessProxyWorker = /** @class */ (function () {
    function ChildProcessProxyWorker() {
        this.log = log4js_1.getLogger(ChildProcessProxyWorker.name);
        this.listenToParent();
    }
    ChildProcessProxyWorker.prototype.send = function (value) {
        if (process.send) {
            process.send(objectUtils_1.serialize(value));
        }
    };
    ChildProcessProxyWorker.prototype.listenToParent = function () {
        var _this = this;
        var handler = function (serializedMessage) {
            var message = objectUtils_1.deserialize(serializedMessage, [core_1.File]);
            switch (message.kind) {
                case messageProtocol_1.WorkerMessageKind.Init:
                    log4js_1.setGlobalLogLevel(message.logLevel);
                    new PluginLoader_1.default(message.plugins).load();
                    var RealSubjectClass = require(message.requirePath).default;
                    _this.realSubject = new (RealSubjectClass.bind.apply(RealSubjectClass, [void 0].concat(message.constructorArgs)))();
                    _this.send({ kind: messageProtocol_1.ParentMessageKind.Initialized });
                    _this.removeAnyAdditionalMessageListeners(handler);
                    break;
                case messageProtocol_1.WorkerMessageKind.Work:
                    new Promise(function (resolve) {
                        var _a;
                        return resolve((_a = _this.realSubject)[message.methodName].apply(_a, message.args));
                    })
                        .then(function (result) {
                        _this.send({
                            kind: messageProtocol_1.ParentMessageKind.Result,
                            correlationId: message.correlationId,
                            result: result
                        });
                    }).catch(function (error) {
                        _this.send({
                            kind: messageProtocol_1.ParentMessageKind.Rejection,
                            error: objectUtils_1.errorToString(error),
                            correlationId: message.correlationId
                        });
                    });
                    _this.removeAnyAdditionalMessageListeners(handler);
                    break;
            }
        };
        process.on('message', handler);
    };
    /**
     * Remove any addition message listeners that might me eavesdropping.
     * the @ngtools/webpack plugin listens to messages and throws an error whenever it could not handle a message
     * @see https://github.com/angular/angular-cli/blob/f776d3cf7982b64734c57fe4407434e9f4ec09f7/packages/%40ngtools/webpack/src/type_checker.ts#L79
     * @param exceptListener The listener that should remain
     */
    ChildProcessProxyWorker.prototype.removeAnyAdditionalMessageListeners = function (exceptListener) {
        var _this = this;
        process.listeners('message').forEach(function (listener) {
            if (listener !== exceptListener) {
                _this.log.debug('Removing an additional message listener, we don\'t want eavesdropping on our inter-process communication: %s', listener.toString());
                process.removeListener('message', listener);
            }
        });
    };
    return ChildProcessProxyWorker;
}());
exports.default = ChildProcessProxyWorker;
// Prevent side effects for merely requiring the file
// Only actually start the child worker when it is requested
if (process.argv.indexOf(messageProtocol_1.autoStart) !== -1) {
    new ChildProcessProxyWorker();
}
//# sourceMappingURL=ChildProcessProxyWorker.js.map