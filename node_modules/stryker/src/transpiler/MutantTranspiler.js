"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var rxjs_1 = require("rxjs");
var TranspilerFacade_1 = require("./TranspilerFacade");
var core_1 = require("stryker-api/core");
var ChildProcessProxy_1 = require("../child-proxy/ChildProcessProxy");
var TranspiledMutant_1 = require("../TranspiledMutant");
var objectUtils_1 = require("../utils/objectUtils");
var MutantTranspiler = /** @class */ (function () {
    /**
     * Creates the mutant transpiler in a child process if one is defined.
     * Otherwise will just forward input as output in same process.
     * @param config The Stryker config
     */
    function MutantTranspiler(config) {
        var transpilerOptions = { config: config, produceSourceMaps: false };
        if (config.transpilers.length) {
            this.transpilerChildProcess = ChildProcessProxy_1.default.create(require.resolve('./TranspilerFacade'), config.logLevel, config.plugins, TranspilerFacade_1.default, transpilerOptions);
            this.proxy = this.transpilerChildProcess.proxy;
        }
        else {
            this.proxy = new TranspilerFacade_1.default(transpilerOptions);
        }
    }
    MutantTranspiler.prototype.initialize = function (files) {
        var _this = this;
        return this.proxy.transpile(files).then(function (transpiledFiles) {
            _this.unMutatedFiles = transpiledFiles;
            return transpiledFiles;
        });
    };
    MutantTranspiler.prototype.transpileMutants = function (allMutants) {
        var _this = this;
        var mutants = allMutants.slice();
        return new rxjs_1.Observable(function (observer) {
            var nextMutant = function () {
                var mutant = mutants.shift();
                if (mutant) {
                    _this.transpileMutant(mutant)
                        .then(function (transpiledFiles) { return observer.next(_this.createTranspiledMutant(mutant, transpiledFiles, _this.unMutatedFiles)); })
                        .then(nextMutant)
                        .catch(function (error) { return observer.error(error); });
                }
                else {
                    observer.complete();
                }
            };
            nextMutant();
        });
    };
    MutantTranspiler.prototype.dispose = function () {
        if (this.transpilerChildProcess) {
            this.transpilerChildProcess.dispose();
        }
    };
    MutantTranspiler.prototype.createTranspiledMutant = function (mutant, transpileResult, unMutatedFiles) {
        return new TranspiledMutant_1.default(mutant, transpileResult, someFilesChanged());
        function someFilesChanged() {
            return transpileResult.outputFiles.some(function (file) { return fileChanged(file); });
        }
        function fileChanged(file) {
            if (unMutatedFiles) {
                var unMutatedFile = unMutatedFiles.find(function (f) { return f.name === file.name; });
                return !unMutatedFile || unMutatedFile.textContent !== file.textContent;
            }
            else {
                return true;
            }
        }
    };
    MutantTranspiler.prototype.transpileMutant = function (mutant) {
        var filesToTranspile = [];
        if (this.currentMutatedFile && this.currentMutatedFile.name !== mutant.fileName) {
            filesToTranspile.push(this.currentMutatedFile.file);
        }
        this.currentMutatedFile = mutant.sourceFile;
        var mutatedFile = new core_1.File(mutant.fileName, Buffer.from(mutant.mutatedCode));
        filesToTranspile.push(mutatedFile);
        return this.proxy.transpile(filesToTranspile)
            .then(function (transpiledFiles) { return ({ outputFiles: transpiledFiles, error: null }); })
            .catch(function (error) { return ({ outputFiles: [], error: objectUtils_1.errorToString(error) }); });
    };
    return MutantTranspiler;
}());
exports.default = MutantTranspiler;
//# sourceMappingURL=MutantTranspiler.js.map