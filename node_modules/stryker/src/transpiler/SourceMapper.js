"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var path = require("path");
var source_map_1 = require("source-map");
var core_1 = require("stryker-api/core");
var objectUtils_1 = require("../utils/objectUtils");
var log4js_1 = require("log4js");
var StrykerError_1 = require("../utils/StrykerError");
var SOURCE_MAP_URL_REGEX = /\/\/\s*#\s*sourceMappingURL=(.*)/g;
var SourceMapError = /** @class */ (function (_super) {
    tslib_1.__extends(SourceMapError, _super);
    function SourceMapError(message, innerError) {
        var _this = _super.call(this, message + ". Cannot analyse code coverage. Setting `coverageAnalysis: \"off\"` in your stryker.conf.js will prevent this error, but forces Stryker to run each test for each mutant.", innerError) || this;
        Error.captureStackTrace(_this, SourceMapError);
        // TS recommendation: https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work
        Object.setPrototypeOf(_this, SourceMapError.prototype);
        return _this;
    }
    return SourceMapError;
}(StrykerError_1.default));
exports.SourceMapError = SourceMapError;
/**
 * Represents an object that can calculated a transpiled location for a given original location
 * It is implemented with the [composite pattern](https://en.wikipedia.org/wiki/Composite_pattern)
 * Use the `create` method to retrieve a specific `SourceMapper` implementation
 */
var SourceMapper = /** @class */ (function () {
    function SourceMapper() {
    }
    SourceMapper.create = function (transpiledFiles, config) {
        if (config.transpilers.length && config.coverageAnalysis !== 'off') {
            return new TranspiledSourceMapper(transpiledFiles);
        }
        else {
            return new PassThroughSourceMapper();
        }
    };
    return SourceMapper;
}());
exports.default = SourceMapper;
var TranspiledSourceMapper = /** @class */ (function (_super) {
    tslib_1.__extends(TranspiledSourceMapper, _super);
    function TranspiledSourceMapper(transpiledFiles) {
        var _this = _super.call(this) || this;
        _this.transpiledFiles = transpiledFiles;
        _this.log = log4js_1.getLogger(SourceMapper.name);
        return _this;
    }
    /**
     * @inheritDoc
     */
    TranspiledSourceMapper.prototype.transpiledFileNameFor = function (originalFileName) {
        var sourceMap = this.getSourceMap(originalFileName);
        return sourceMap.transpiledFile.name;
    };
    /**
     * @inheritdoc
     */
    TranspiledSourceMapper.prototype.transpiledLocationFor = function (originalLocation) {
        var sourceMap = this.getSourceMap(originalLocation.fileName);
        var relativeSource = this.getRelativeSource(sourceMap, originalLocation);
        var start = sourceMap.generatedPositionFor(originalLocation.location.start, relativeSource);
        var end = sourceMap.generatedPositionFor(originalLocation.location.end, relativeSource);
        return {
            fileName: sourceMap.transpiledFile.name,
            location: {
                start: start,
                end: end
            }
        };
    };
    TranspiledSourceMapper.prototype.getRelativeSource = function (from, to) {
        return path.relative(path.dirname(from.sourceMapFileName), to.fileName)
            .replace(/\\/g, '/');
    };
    /**
     * Gets the source map for given file
     */
    TranspiledSourceMapper.prototype.getSourceMap = function (sourceFileName) {
        if (!this.sourceMaps) {
            this.sourceMaps = this.createSourceMaps();
        }
        var sourceMap = this.sourceMaps[path.resolve(sourceFileName)];
        if (sourceMap) {
            return sourceMap;
        }
        else {
            throw new SourceMapError("Source map not found for \"" + sourceFileName + "\"");
        }
    };
    /**
     * Creates all source maps for lazy loading purposes
     */
    TranspiledSourceMapper.prototype.createSourceMaps = function () {
        var _this = this;
        var sourceMaps = Object.create(null);
        this.transpiledFiles.forEach(function (transpiledFile) {
            var sourceMapFile = _this.getSourceMapForFile(transpiledFile);
            if (sourceMapFile) {
                var rawSourceMap = _this.getRawSourceMap(sourceMapFile);
                var sourceMap_1 = new SourceMap(transpiledFile, sourceMapFile.name, rawSourceMap);
                rawSourceMap.sources.forEach(function (source) {
                    var sourceFileName = path.resolve(path.dirname(sourceMapFile.name), source);
                    sourceMaps[sourceFileName] = sourceMap_1;
                });
            }
        });
        return sourceMaps;
    };
    TranspiledSourceMapper.prototype.getRawSourceMap = function (sourceMapFile) {
        try {
            return JSON.parse(sourceMapFile.textContent);
        }
        catch (error) {
            throw new SourceMapError("Source map file \"" + sourceMapFile.name + "\" could not be parsed as json", error);
        }
    };
    TranspiledSourceMapper.prototype.getSourceMapForFile = function (transpiledFile) {
        var sourceMappingUrl = this.getSourceMapUrl(transpiledFile);
        if (sourceMappingUrl) {
            return this.getSourceMapFileFromUrl(sourceMappingUrl, transpiledFile);
        }
        else {
            return null;
        }
    };
    /**
     * Gets the source map file from a url.
     * @param sourceMapUrl The source map url. Can be a data url (data:application/json;base64,ABC...), or an actual file url
     * @param transpiledFile The transpiled file for which the data url is
     */
    TranspiledSourceMapper.prototype.getSourceMapFileFromUrl = function (sourceMapUrl, transpiledFile) {
        var sourceMapFile = this.isInlineUrl(sourceMapUrl) ?
            this.getInlineSourceMap(sourceMapUrl, transpiledFile) : this.getExternalSourceMap(sourceMapUrl, transpiledFile);
        return sourceMapFile;
    };
    TranspiledSourceMapper.prototype.isInlineUrl = function (sourceMapUrl) {
        return sourceMapUrl.startsWith('data:');
    };
    /**
     * Gets the source map from a data url
     */
    TranspiledSourceMapper.prototype.getInlineSourceMap = function (sourceMapUrl, transpiledFile) {
        var supportedDataPrefix = 'data:application/json;base64,';
        if (sourceMapUrl.startsWith(supportedDataPrefix)) {
            var content = objectUtils_1.base64Decode(sourceMapUrl.substr(supportedDataPrefix.length));
            return new core_1.File(transpiledFile.name, content);
        }
        else {
            throw new SourceMapError("Source map file for \"" + transpiledFile.name + "\" cannot be read. Data url \"" + sourceMapUrl.substr(0, sourceMapUrl.lastIndexOf(',')) + "\" found, where \"" + supportedDataPrefix.substr(0, supportedDataPrefix.length - 1) + "\" was expected");
        }
    };
    /**
     * Gets the source map from a file
     */
    TranspiledSourceMapper.prototype.getExternalSourceMap = function (sourceMapUrl, transpiledFile) {
        var sourceMapFileName = path.resolve(path.dirname(transpiledFile.name), sourceMapUrl);
        var sourceMapFile = this.transpiledFiles.find(function (file) { return path.resolve(file.name) === sourceMapFileName; });
        if (sourceMapFile) {
            return sourceMapFile;
        }
        else {
            throw new SourceMapError("Source map file \"" + sourceMapUrl + "\" (referenced by \"" + transpiledFile.name + "\") cannot be found in list of transpiled files");
        }
    };
    /**
     * Gets the source map url from a transpiled file (the last comment with sourceMappingURL= ...)
     */
    TranspiledSourceMapper.prototype.getSourceMapUrl = function (transpiledFile) {
        SOURCE_MAP_URL_REGEX.lastIndex = 0;
        var currentMatch;
        var lastMatch = null;
        // Retrieve the final sourceMappingURL comment in the file
        while (currentMatch = SOURCE_MAP_URL_REGEX.exec(transpiledFile.textContent)) {
            lastMatch = currentMatch;
        }
        if (lastMatch) {
            this.log.debug('Source map url found in transpiled file "%s"', transpiledFile.name);
            return lastMatch[1];
        }
        else {
            this.log.debug('No source map url found in transpiled file "%s"', transpiledFile.name);
            return null;
        }
    };
    return TranspiledSourceMapper;
}(SourceMapper));
exports.TranspiledSourceMapper = TranspiledSourceMapper;
var PassThroughSourceMapper = /** @class */ (function (_super) {
    tslib_1.__extends(PassThroughSourceMapper, _super);
    function PassThroughSourceMapper() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @inheritdoc
     */
    PassThroughSourceMapper.prototype.transpiledFileNameFor = function (originalFileName) {
        return originalFileName;
    };
    /**
     * @inheritdoc
     */
    PassThroughSourceMapper.prototype.transpiledLocationFor = function (originalLocation) {
        return originalLocation;
    };
    return PassThroughSourceMapper;
}(SourceMapper));
exports.PassThroughSourceMapper = PassThroughSourceMapper;
var SourceMap = /** @class */ (function () {
    function SourceMap(transpiledFile, sourceMapFileName, rawSourceMap) {
        this.transpiledFile = transpiledFile;
        this.sourceMapFileName = sourceMapFileName;
        this.sourceMap = new source_map_1.SourceMapConsumer(rawSourceMap);
    }
    SourceMap.prototype.generatedPositionFor = function (originalPosition, relativeSource) {
        var transpiledPosition = this.sourceMap.generatedPositionFor({
            bias: source_map_1.SourceMapConsumer.LEAST_UPPER_BOUND,
            column: originalPosition.column,
            line: originalPosition.line + 1,
            source: relativeSource
        });
        return {
            line: transpiledPosition.line - 1,
            column: transpiledPosition.column
        };
    };
    return SourceMap;
}());
//# sourceMappingURL=SourceMapper.js.map