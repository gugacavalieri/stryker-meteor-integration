"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var istanbul_lib_instrument_1 = require("istanbul-lib-instrument");
var core_1 = require("stryker-api/core");
var coverageHooks_1 = require("./coverageHooks");
var StrykerError_1 = require("../utils/StrykerError");
var CoverageInstrumenterTranspiler = /** @class */ (function () {
    function CoverageInstrumenterTranspiler(settings, filesToInstrument) {
        this.settings = settings;
        this.filesToInstrument = filesToInstrument;
        this.fileCoverageMaps = Object.create(null);
        this.instrumenter = istanbul_lib_instrument_1.createInstrumenter({ coverageVariable: this.coverageVariable, preserveComments: true });
    }
    CoverageInstrumenterTranspiler.prototype.transpile = function (files) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, files.map(function (file) { return _this.instrumentFileIfNeeded(file); })];
            });
        });
    };
    Object.defineProperty(CoverageInstrumenterTranspiler.prototype, "coverageVariable", {
        /**
         * Coverage variable *must* have the name '__coverage__'. Only that variable
         * is reported back to the TestRunner process when using one of the karma
         * test framework adapters (karma-jasmine, karma-mocha, ...).
         *
         * However, when coverageAnalysis is 'perTest' we don't choose that variable name right away,
         * because we need that variable to hold all coverage results per test. Instead, we use __strykerCoverageCurrentTest__
         * and after each test copy over the value of that current test to the global coverage object __coverage__
         */
        get: function () {
            switch (this.settings.coverageAnalysis) {
                case 'perTest':
                    return coverageHooks_1.COVERAGE_CURRENT_TEST_VARIABLE_NAME;
                default:
                    return '__coverage__';
            }
        },
        enumerable: true,
        configurable: true
    });
    CoverageInstrumenterTranspiler.prototype.patchRanges = function (fileCoverage) {
        function patchRange(range) {
            // Lines from istanbul are one-based, lines in Stryker are 0-based
            range.end.line--;
            range.start.line--;
        }
        Object.keys(fileCoverage.statementMap).forEach(function (key) { return patchRange(fileCoverage.statementMap[key]); });
        Object.keys(fileCoverage.branchMap).forEach(function (key) {
            patchRange(fileCoverage.branchMap[key].loc);
            fileCoverage.branchMap[key].locations.forEach(patchRange);
            fileCoverage.branchMap[key].line--;
        });
        Object.keys(fileCoverage.fnMap).forEach(function (key) {
            patchRange(fileCoverage.fnMap[key].loc);
            patchRange(fileCoverage.fnMap[key].decl);
            fileCoverage.fnMap[key].line--;
        });
        return fileCoverage;
    };
    CoverageInstrumenterTranspiler.prototype.instrumentFileIfNeeded = function (file) {
        if (this.settings.coverageAnalysis !== 'off' && this.filesToInstrument.some(function (fileName) { return fileName === file.name; })) {
            return this.instrumentFile(file);
        }
        else {
            return file;
        }
    };
    CoverageInstrumenterTranspiler.prototype.instrumentFile = function (sourceFile) {
        try {
            var content = this.instrumenter.instrumentSync(sourceFile.textContent, sourceFile.name);
            var fileCoverage = this.patchRanges(this.instrumenter.lastFileCoverage());
            this.fileCoverageMaps[sourceFile.name] = this.retrieveCoverageMaps(fileCoverage);
            return new core_1.File(sourceFile.name, Buffer.from(content));
        }
        catch (error) {
            throw new StrykerError_1.default("Could not instrument \"" + sourceFile.name + "\" for code coverage", error);
        }
    };
    CoverageInstrumenterTranspiler.prototype.retrieveCoverageMaps = function (input) {
        var output = {
            statementMap: input.statementMap,
            fnMap: {}
        };
        Object.keys(input.fnMap).forEach(function (key) { return output.fnMap[key] = input.fnMap[key].loc; });
        return output;
    };
    return CoverageInstrumenterTranspiler;
}());
exports.default = CoverageInstrumenterTranspiler;
//# sourceMappingURL=CoverageInstrumenterTranspiler.js.map