"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var events_1 = require("events");
var log4js_1 = require("log4js");
var _ = require("lodash");
var child_process_1 = require("child_process");
var objectUtils_1 = require("../utils/objectUtils");
var Task_1 = require("../utils/Task");
var MAX_WAIT_FOR_DISPOSE = 2000;
var InitTask = /** @class */ (function (_super) {
    tslib_1.__extends(InitTask, _super);
    function InitTask() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.kind = 'init';
        return _this;
    }
    return InitTask;
}(Task_1.default));
var DisposeTask = /** @class */ (function (_super) {
    tslib_1.__extends(DisposeTask, _super);
    function DisposeTask() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.kind = 'dispose';
        return _this;
    }
    return DisposeTask;
}(Task_1.default));
var RunTask = /** @class */ (function (_super) {
    tslib_1.__extends(RunTask, _super);
    function RunTask() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.kind = 'run';
        return _this;
    }
    return RunTask;
}(Task_1.default));
/**
 * Runs the given test runner in a child process and forwards reports about test results
 * Also implements timeout-mechanism (on timeout, restart the child runner and report timeout)
 */
var TestRunnerChildProcessAdapter = /** @class */ (function (_super) {
    tslib_1.__extends(TestRunnerChildProcessAdapter, _super);
    function TestRunnerChildProcessAdapter(realTestRunnerName, options) {
        var _this = _super.call(this) || this;
        _this.realTestRunnerName = realTestRunnerName;
        _this.options = options;
        _this.log = log4js_1.getLogger(TestRunnerChildProcessAdapter.name);
        _this.lastMessagesQueue = [];
        _this.startWorker();
        return _this;
    }
    TestRunnerChildProcessAdapter.prototype.startWorker = function () {
        // Remove --debug-brk from process arguments. 
        // When debugging, it will try to reuse the same debug port, which will be taken by the main process.
        var execArgv = _.clone(process.execArgv);
        _.remove(execArgv, function (arg) { return arg.substr(0, 11) === '--debug-brk'; });
        this.workerProcess = child_process_1.fork(__dirname + "/IsolatedTestRunnerAdapterWorker", [], { silent: true, execArgv: [] });
        this.sendStartCommand();
        this.listenToWorkerProcess();
    };
    TestRunnerChildProcessAdapter.prototype.listenToWorkerProcess = function () {
        var _this = this;
        if (this.workerProcess.stdout) {
            var traceEnabled_1 = this.log.isTraceEnabled();
            this.workerProcess.stdout.on('data', function (data) {
                var msg = data.toString();
                _this.lastMessagesQueue.push(msg);
                if (_this.lastMessagesQueue.length > 10) {
                    _this.lastMessagesQueue.shift();
                }
                if (traceEnabled_1) {
                    _this.log.trace(msg);
                }
            });
        }
        if (this.workerProcess.stderr) {
            this.workerProcess.stderr.on('data', function (data) {
                _this.log.error(data.toString());
            });
        }
        this.workerProcess.on('message', function (message) {
            switch (message.kind) {
                case 'result':
                    if (_this.currentTask.kind === 'run') {
                        _this.currentTask.resolve(message.result);
                    }
                    else {
                        _this.logReceivedUnexpectedMessageWarning(message);
                    }
                    break;
                case 'initDone':
                    if (_this.currentTask.kind === 'init') {
                        if (message.errorMessage) {
                            _this.currentTask.reject(message.errorMessage);
                        }
                        else {
                            _this.currentTask.resolve(undefined);
                        }
                    }
                    else {
                        _this.logReceivedUnexpectedMessageWarning(message);
                    }
                    break;
                case 'disposeDone':
                    if (_this.currentTask.kind === 'dispose') {
                        _this.currentTask.resolve(undefined);
                    }
                    else {
                        _this.logReceivedUnexpectedMessageWarning(message);
                    }
                    break;
                default:
                    _this.logReceivedMessageWarning(message);
                    break;
            }
        });
        this.workerProcess.on('exit', function (code, signal) {
            if (code !== 0 && code !== null) {
                _this.log.error("Child process exited with non-zero exit code " + code + ". Last 10 message from the child process were: \r\n" + _this.lastMessagesQueue.map(function (msg) { return "\t" + msg; }).join('\r\n'));
                if (_this.currentTask) {
                    _this.currentTask.reject("Test runner child process exited with non-zero exit code " + code);
                }
            }
        });
    };
    TestRunnerChildProcessAdapter.prototype.logReceivedUnexpectedMessageWarning = function (message) {
        this.log.warn("Received unexpected message from test runner worker process: \"" + message.kind + "\" while current task is " + this.currentTask.kind + ". Ignoring this message.");
    };
    TestRunnerChildProcessAdapter.prototype.logReceivedMessageWarning = function (message) {
        this.log.error("Retrieved unrecognized message from child process: " + JSON.stringify(message));
    };
    TestRunnerChildProcessAdapter.prototype.init = function () {
        this.currentTask = new InitTask();
        this.sendInitCommand();
        return this.currentTask.promise;
    };
    TestRunnerChildProcessAdapter.prototype.run = function (options) {
        this.currentTask = new RunTask();
        this.sendRunCommand(options);
        return this.currentTask.promise;
    };
    TestRunnerChildProcessAdapter.prototype.dispose = function () {
        var _this = this;
        this.currentTask = new DisposeTask(MAX_WAIT_FOR_DISPOSE);
        this.sendDisposeCommand();
        return this.currentTask.promise
            .then(function () { return objectUtils_1.kill(_this.workerProcess.pid); });
    };
    TestRunnerChildProcessAdapter.prototype.sendRunCommand = function (options) {
        this.send({
            kind: 'run',
            runOptions: options
        });
    };
    TestRunnerChildProcessAdapter.prototype.send = function (message) {
        try {
            // Serialize message before sending to preserve all javascript, including regex's and functions
            // See https://github.com/stryker-mutator/stryker/issues/143
            this.workerProcess.send(objectUtils_1.serialize(message));
        }
        catch (error) {
            this.currentTask.reject(error);
        }
    };
    TestRunnerChildProcessAdapter.prototype.sendStartCommand = function () {
        this.send({
            kind: 'start',
            runnerName: this.realTestRunnerName,
            runnerOptions: this.options
        });
    };
    TestRunnerChildProcessAdapter.prototype.sendInitCommand = function () {
        this.send({ kind: 'init' });
    };
    TestRunnerChildProcessAdapter.prototype.sendDisposeCommand = function () {
        this.send({ kind: 'dispose' });
    };
    return TestRunnerChildProcessAdapter;
}(events_1.EventEmitter));
exports.default = TestRunnerChildProcessAdapter;
//# sourceMappingURL=IsolatedTestRunnerAdapter.js.map