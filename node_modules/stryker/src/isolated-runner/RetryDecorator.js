"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var test_runner_1 = require("stryker-api/test_runner");
var objectUtils_1 = require("../utils/objectUtils");
var TestRunnerDecorator_1 = require("./TestRunnerDecorator");
var Task_1 = require("../utils/Task");
var BROKEN_PIPE_ERROR_CODE = 'EPIPE';
var ERROR_MESSAGE = 'Test runner crashed. Tried twice to restart it without any luck. Last time the error message was: ';
/**
 * Wraps a test runner and implements the retry functionality.
 */
var RetryDecorator = /** @class */ (function (_super) {
    tslib_1.__extends(RetryDecorator, _super);
    function RetryDecorator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    RetryDecorator.prototype.run = function (options) {
        this.currentRunTask = new Task_1.default();
        this.tryRun(options);
        return this.currentRunTask.promise;
    };
    RetryDecorator.prototype.dispose = function () {
        var _this = this;
        return _super.prototype.dispose.call(this).catch(function (err) {
            if (_this.innerProcessIsCrashed(err)) {
                return null;
            }
            else {
                // Oops, not intended to catch this one. Pass through
                throw err;
            }
        });
    };
    RetryDecorator.prototype.innerProcessIsCrashed = function (error) {
        return objectUtils_1.isErrnoException(error) && error.code === BROKEN_PIPE_ERROR_CODE;
    };
    RetryDecorator.prototype.tryRun = function (options, retriesLeft, lastError) {
        var _this = this;
        if (retriesLeft === void 0) { retriesLeft = 2; }
        if (retriesLeft > 0) {
            this.innerRunner.run(options).then(function (result) {
                return _this.currentRunTask.resolve(result);
            }, function (rejectReason) {
                if (_this.innerProcessIsCrashed(rejectReason)) {
                    _this.recover().then(function () { return _this.tryRun(options, retriesLeft - 1, rejectReason); }, function (reason) { return _this.currentRunTask.reject(reason); });
                }
                else {
                    // Oops... not intended to catch this one
                    _this.currentRunTask.reject(rejectReason);
                }
            });
        }
        else {
            this.recover().then(function () { return _this.currentRunTask.resolve({ status: test_runner_1.RunStatus.Error, errorMessages: [ERROR_MESSAGE + objectUtils_1.errorToString(lastError)], tests: [] }); }, function (reason) { return _this.currentRunTask.reject(reason); });
        }
    };
    RetryDecorator.prototype.recover = function () {
        this.createInnerRunner();
        return this.init();
    };
    return RetryDecorator;
}(TestRunnerDecorator_1.default));
exports.default = RetryDecorator;
//# sourceMappingURL=RetryDecorator.js.map