"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var test_runner_1 = require("stryker-api/test_runner");
var PluginLoader_1 = require("../PluginLoader");
var log4js_1 = require("log4js");
var objectUtils_1 = require("../utils/objectUtils");
var IsolatedTestRunnerAdapterWorker = /** @class */ (function () {
    function IsolatedTestRunnerAdapterWorker() {
        this.log = log4js_1.getLogger(IsolatedTestRunnerAdapterWorker.name);
        this.handlePromiseRejections();
        this.listenToMessages();
    }
    IsolatedTestRunnerAdapterWorker.prototype.listenToMessages = function () {
        var _this = this;
        process.on('message', function (serializedMessage) {
            var message = objectUtils_1.deserialize(serializedMessage);
            switch (message.kind) {
                case 'start':
                    _this.start(message);
                    break;
                case 'run':
                    _this.run(message);
                    break;
                case 'init':
                    _this.init();
                    break;
                case 'dispose':
                    _this.dispose();
                    break;
                default:
                    _this.logReceivedMessageWarning(message);
            }
        });
    };
    /**
     * During mutation testing, it's to be expected that promise rejections are not handled synchronously anymore (or not at all)
     * Let's handle those events so future versions of node don't crash
     * See issue 350: https://github.com/stryker-mutator/stryker/issues/350
     */
    IsolatedTestRunnerAdapterWorker.prototype.handlePromiseRejections = function () {
        var _this = this;
        var unhandledRejections = [];
        process.on('unhandledRejection', function (reason, promise) {
            var unhandledPromiseId = unhandledRejections.push(promise);
            _this.log.debug("UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: " + unhandledPromiseId + "): " + reason);
        });
        process.on('rejectionHandled', function (promise) {
            var unhandledPromiseId = unhandledRejections.indexOf(promise) + 1;
            _this.log.debug("PromiseRejectionHandledWarning: Promise rejection was handled asynchronously (rejection id: " + unhandledPromiseId + ")");
        });
    };
    IsolatedTestRunnerAdapterWorker.prototype.logReceivedMessageWarning = function (message) {
        this.log.warn('Received unsupported message: {}', JSON.stringify(message));
    };
    IsolatedTestRunnerAdapterWorker.prototype.start = function (message) {
        this.loadPlugins(message.runnerOptions.strykerOptions.plugins || []);
        this.log.debug("Changing current working directory for this process to " + message.runnerOptions.sandboxWorkingFolder);
        process.chdir(message.runnerOptions.sandboxWorkingFolder);
        this.underlyingTestRunner = test_runner_1.TestRunnerFactory.instance().create(message.runnerName, message.runnerOptions);
    };
    IsolatedTestRunnerAdapterWorker.prototype.init = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var err_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.underlyingTestRunner.init) return [3 /*break*/, 4];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.underlyingTestRunner.init()];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        err_1 = _a.sent();
                        this.sendInitDone(objectUtils_1.errorToString(err_1));
                        return [3 /*break*/, 4];
                    case 4:
                        this.sendInitDone();
                        return [2 /*return*/];
                }
            });
        });
    };
    IsolatedTestRunnerAdapterWorker.prototype.sendInitDone = function (errorMessage) {
        if (errorMessage === void 0) { errorMessage = null; }
        var message = { kind: 'initDone', errorMessage: errorMessage };
        if (process.send) {
            process.send(message);
        }
    };
    IsolatedTestRunnerAdapterWorker.prototype.dispose = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.underlyingTestRunner.dispose) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.underlyingTestRunner.dispose()];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        this.sendDisposeDone();
                        return [2 /*return*/];
                }
            });
        });
    };
    IsolatedTestRunnerAdapterWorker.prototype.sendDisposeDone = function () {
        this.send({ kind: 'disposeDone' });
    };
    IsolatedTestRunnerAdapterWorker.prototype.run = function (body) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var res, error_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.underlyingTestRunner.run(body.runOptions)];
                    case 1:
                        res = _a.sent();
                        this.reportResult(res);
                        return [3 /*break*/, 3];
                    case 2:
                        error_1 = _a.sent();
                        this.reportErrorResult(error_1);
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    IsolatedTestRunnerAdapterWorker.prototype.send = function (message) {
        if (process.send) {
            process.send(message);
        }
    };
    IsolatedTestRunnerAdapterWorker.prototype.loadPlugins = function (plugins) {
        new PluginLoader_1.default(plugins).load();
    };
    IsolatedTestRunnerAdapterWorker.prototype.reportResult = function (result) {
        // If the test runner didn't report on coverage, let's try to do it ourselves.
        if (!result.coverage) {
            result.coverage = (Function('return this'))().__coverage__;
        }
        if (result.errorMessages) {
            // errorMessages should be a string[]
            // Just in case the test runner implementer forgot to convert `Error`s to string, we will do it here
            // https://github.com/stryker-mutator/stryker/issues/141
            result.errorMessages = result.errorMessages.map(objectUtils_1.errorToString);
        }
        this.send({
            kind: 'result',
            result: result
        });
    };
    IsolatedTestRunnerAdapterWorker.prototype.reportErrorResult = function (error) {
        var runResult = {
            tests: [],
            status: test_runner_1.RunStatus.Error,
        };
        if (error) {
            if (Array.isArray(error)) {
                runResult.errorMessages = error.map(function (e) { return e; });
            }
            else {
                runResult.errorMessages = [error];
            }
        }
        this.reportResult(runResult);
    };
    return IsolatedTestRunnerAdapterWorker;
}());
new IsolatedTestRunnerAdapterWorker();
//# sourceMappingURL=IsolatedTestRunnerAdapterWorker.js.map