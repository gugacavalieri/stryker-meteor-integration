"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var os = require("os");
var _ = require("lodash");
var chalk_1 = require("chalk");
var FILES_ROOT_NAME = 'All files';
var repeat = function (char, nTimes) { return new Array(nTimes > -1 ? nTimes + 1 : 0).join(char); };
var spaces = function (n) { return repeat(' ', n); };
var dots = function (n) { return repeat('.', n); };
/**
 * Represents a column in the clear text table
 */
var Column = /** @class */ (function () {
    function Column(header, valueFactory, rows) {
        this.header = header;
        this.valueFactory = valueFactory;
        this.rows = rows;
        var maxContentSize = this.determineValueSize();
        this.width = this.pad(dots(maxContentSize)).length;
    }
    Column.prototype.determineValueSize = function (row, ancestorCount) {
        var _this = this;
        if (row === void 0) { row = this.rows; }
        if (ancestorCount === void 0) { ancestorCount = 0; }
        var valueWidths = row.childResults.map(function (child) { return _this.determineValueSize(child, ancestorCount + 1); });
        valueWidths.push(this.header.length);
        valueWidths.push(this.valueFactory(row, ancestorCount).length);
        return Math.max.apply(Math, valueWidths);
    };
    /**
     * Adds padding (spaces) to the front and end of a value
     * @param input The string input
     */
    Column.prototype.pad = function (input) {
        return spaces(this.width - input.length - 2) + " " + input + " ";
    };
    Column.prototype.drawLine = function () {
        return repeat('-', this.width);
    };
    Column.prototype.drawTableCell = function (score, ancestorCount) {
        return this.color(score)(this.pad(this.valueFactory(score, ancestorCount)));
    };
    Column.prototype.drawHeader = function () {
        return this.pad(this.header);
    };
    Column.prototype.color = function (score) {
        return function (input) { return input; };
    };
    return Column;
}());
var MutationScoreColumn = /** @class */ (function (_super) {
    tslib_1.__extends(MutationScoreColumn, _super);
    function MutationScoreColumn(rows, thresholds) {
        var _this = _super.call(this, '% score', function (row) { return row.mutationScore.toFixed(2); }, rows) || this;
        _this.thresholds = thresholds;
        return _this;
    }
    MutationScoreColumn.prototype.color = function (score) {
        if (score.mutationScore >= this.thresholds.high) {
            return chalk_1.default.green;
        }
        else if (score.mutationScore >= this.thresholds.low) {
            return chalk_1.default.yellow;
        }
        else {
            return chalk_1.default.red;
        }
    };
    return MutationScoreColumn;
}(Column));
var FileColumn = /** @class */ (function (_super) {
    tslib_1.__extends(FileColumn, _super);
    function FileColumn(rows) {
        return _super.call(this, 'File', function (row, ancestorCount) { return spaces(ancestorCount) + (ancestorCount === 0 ? FILES_ROOT_NAME : row.name); }, rows) || this;
    }
    FileColumn.prototype.pad = function (input) {
        return input + " " + spaces(this.width - input.length - 1);
    };
    return FileColumn;
}(Column));
/**
 * Represents a clear text table for mutation score
 */
var ClearTextScoreTable = /** @class */ (function () {
    function ClearTextScoreTable(score, thresholds) {
        this.score = score;
        this.columns = [
            new FileColumn(score),
            new MutationScoreColumn(score, thresholds),
            new Column('# killed', function (row) { return row.killed.toString(); }, score),
            new Column('# timeout', function (row) { return row.timedOut.toString(); }, score),
            new Column('# survived', function (row) { return row.survived.toString(); }, score),
            new Column('# no cov', function (row) { return row.noCoverage.toString(); }, score),
            new Column('# error', function (row) { return (row.runtimeErrors + row.transpileErrors).toString(); }, score)
        ];
    }
    ClearTextScoreTable.prototype.drawBorder = function () {
        return this.drawRow(function (column) { return column.drawLine(); });
    };
    ClearTextScoreTable.prototype.drawHeader = function () {
        return this.drawRow(function (c) { return c.drawHeader(); });
    };
    ClearTextScoreTable.prototype.drawRow = function (toDraw) {
        return this.columns.map(toDraw).join('|') + '|';
    };
    ClearTextScoreTable.prototype.drawValues = function (current, ancestorCount) {
        var _this = this;
        if (current === void 0) { current = this.score; }
        if (ancestorCount === void 0) { ancestorCount = 0; }
        return [this.drawRow(function (c) { return c.drawTableCell(current, ancestorCount); })]
            .concat(_.flatMap(current.childResults, function (child) { return _this.drawValues(child, ancestorCount + 1); }));
    };
    /**
     * Returns a string with the score results drawn in a table.
     */
    ClearTextScoreTable.prototype.draw = function () {
        return [
            this.drawBorder(),
            this.drawHeader(),
            this.drawBorder(),
            this.drawValues().join(os.EOL),
            this.drawBorder()
        ].join(os.EOL);
    };
    return ClearTextScoreTable;
}());
exports.default = ClearTextScoreTable;
//# sourceMappingURL=ClearTextScoreTable.js.map