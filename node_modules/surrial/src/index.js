"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var helpers_1 = require("./helpers");
var os_1 = require("os");
var UID = Math.floor(Math.random() * 0x10000000000).toString(16);
var PLACE_HOLDER_REGEXP = new RegExp('"@__' + UID + '-(\\d+)__@"', 'g');
var IS_NATIVE_CODE_REGEXP = /\{\s*\[native code\]\s*\}/g;
/**
 * Deserializes a string into it's javascript equivalent. CAUTION! Evaluates the string in the current javascript engine
 * (`eval` or one of its friends). Be sure the `serializedThing` comes from a trusted source!
 * @param serializedThing The string to deserialize
 * @param knownClasses A list of known classes used to provide as constructor functions
 */
function deserialize(serializedThing, knownClasses) {
    if (knownClasses === void 0) { knownClasses = []; }
    var evalFn = new (Function.bind.apply(Function, [void 0].concat(knownClasses.map(function (t) { return t.name; }), ["\"use strict\";" + os_1.EOL + "return (" + serializedThing + ");"])))();
    return evalFn.apply(null, knownClasses);
}
exports.deserialize = deserialize;
/**
 * Serializes the thing to a javascript string. This is NOT necessarily a JSON string, but will be valid javascript.
 * @param thing The thing to be serialized
 */
function serialize(thing) {
    if (thing instanceof Date) {
        return serializeDate(thing);
    }
    else if (thing instanceof RegExp) {
        return thing.toString();
    }
    else if (typeof thing === 'function') {
        return serializeFunction(thing);
    }
    else if (thing instanceof Buffer) {
        return serializeBuffer(thing);
    }
    else if (thing instanceof Set) {
        return serializeSet(thing);
    }
    else if (thing instanceof Map) {
        return serializeMap(thing);
    }
    else if (Array.isArray(thing)) {
        return serializeArray(thing);
    }
    else if (helpers_1.isClassInstance(thing)) {
        return serializeClassInstance(thing);
    }
    else {
        return stringifyObject(thing);
    }
}
exports.serialize = serialize;
function serializeArray(thing) {
    return stringifyObject(thing);
}
function stringifyObject(thing) {
    var escapedValues = [];
    // Returns placeholders anything JSON doesn't support (identified by index)
    // which are later replaced by their string representation.
    function replacer(key, value) {
        // If the value is an object w/ a toJSON method, toJSON is called before
        // the replacer runs, so we use this[key] to get the non-toJSONed value.
        var origValue = this[key];
        if ((helpers_1.isClassInstance(origValue) && !Array.isArray(origValue)) || typeof origValue === 'function') {
            return "@__" + UID + "-" + (escapedValues.push(origValue) - 1) + "__@";
        }
        else {
            return value;
        }
    }
    var str = JSON.stringify(thing, replacer, 2);
    // Protects against `JSON.stringify()` returning `undefined`, by serializing
    // to the literal string: "undefined".
    if (typeof str !== 'string') {
        return String(str);
    }
    if (escapedValues.length === 0) {
        return str;
    }
    else {
        // Replaces all occurrences of placeholders in the
        // JSON string with their string representations. If the original value can
        // not be found, then `undefined` is used.
        PLACE_HOLDER_REGEXP.lastIndex = 0;
        return str.replace(PLACE_HOLDER_REGEXP, function (_, valueIndex) { return serialize(escapedValues[valueIndex]); });
    }
}
function serializeSet(value) {
    var valuesArray = [];
    value.forEach(function (v) { return valuesArray.push(serialize(v)); });
    return "new Set([" + valuesArray.join(', ') + "])";
}
function serializeMap(map) {
    var valuesArray = [];
    map.forEach(function (value, key) { return valuesArray.push("[" + serialize(key) + ", " + serialize(value) + "]"); });
    return "new Map([" + valuesArray.join(', ') + "])";
}
function serializeDate(value) {
    return "new Date(\"" + value.toISOString() + "\")";
}
function serializeBuffer(value) {
    return "Buffer.from(" + serialize(value.toString('binary')) + ", \"binary\")";
}
function serializeClassInstance(instance) {
    var constructor = instance.constructor;
    if (constructor.name.length) {
        var params = helpers_1.getParamList(constructor);
        var paramValues = params.map(function (param) { return serialize(instance[param]); });
        var newExpression = "new " + constructor.name + "(" + paramValues.join(', ') + ")";
        return newExpression;
    }
    else {
        throw new Error("Cannot serialize instances of nameless classes (class was defined as: " + constructor.toString() + ")");
    }
}
function serializeFunction(fn) {
    var serializedFn = fn.toString();
    IS_NATIVE_CODE_REGEXP.lastIndex = 0;
    if (IS_NATIVE_CODE_REGEXP.test(serializedFn)) {
        throw new TypeError("Cannot serialize native function: " + fn.name);
    }
    return serializedFn;
}
//# sourceMappingURL=index.js.map